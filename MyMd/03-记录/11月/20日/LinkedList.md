# 基本结构

理解 **`LinkedList`** 的基本结构和源码解析是 Java 集合框架学习的一个重要部分，尤其是在面试中，很多关于 **`LinkedList`** 和 **`ArrayList`** 的性能差异、适用场景和底层实现都会被提到。

以下是第二段学习的详细规划和指导，包括学习步骤、重点、使用背景、以及面试时如何答题等。

### 1. **理解 LinkedList 的基本结构**

**`LinkedList`** 是基于双向链表实现的，每个元素都有两个引用：

- **一个指向前一个元素的引用**（称为 `prev`）
- **一个指向下一个元素的引用**（称为 `next`）

这种结构使得 **`LinkedList`** 可以在 O(1) 时间复杂度内完成插入和删除操作，特别是在链表的头部和尾部。

#### 1.1 链表节点
在 **`LinkedList`** 中，每个节点是一个 **`Node`** 对象，它包含三个基本部分：
- **数据**（存储的数据）
- **指向前一个节点的引用**（`prev`）
- **指向下一个节点的引用**（`next`）

`LinkedList` 内部的 **`Node`** 类通常看起来像这样：

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

#### 1.2 双向链表的结构
- **头节点（Head Node）**：链表的第一个节点，`LinkedList` 的头部。
- **尾节点（Tail Node）**：链表的最后一个节点，`LinkedList` 的尾部。
- 链表的每个节点都连接着前后两个节点，操作时需要更新这些引用。

### 2. **`LinkedList` 源码分析**

在深入理解 **`LinkedList`** 之前，建议先从它的基本操作入手，逐步理解底层实现。你可以查看 `LinkedList` 类的源码，重点关注以下几个方法：
- **`add(E e)`**：插入一个元素到链表的末尾。
- **`remove(Object o)`**：删除指定元素。
- **`get(int index)`**：获取指定索引的元素。
- **`addFirst(E e)`** 和 **`addLast(E e)`**：分别将元素添加到链表的头部和尾部。
- **`removeFirst()`** 和 **`removeLast()`**：分别移除头部和尾部元素。

以下是 `add(E e)` 方法的简单实现分析：

```java
public void add(E e) {
    linkLast(e);
}

void linkLast(E e) {
    final Node<E> l = last; // 获取链表尾部节点
    final Node<E> newNode = new Node<>(l, e, null); // 创建新节点
    last = newNode; // 更新尾部指针
    if (l == null) {
        first = newNode; // 如果链表为空，则新节点同时为头部
    } else {
        l.next = newNode; // 更新旧尾部的 `next` 指针
    }
    size++;
}
```

- **`linkLast`** 方法的作用是将新节点链接到链表的末尾，更新尾部节点的 `next` 引用，并根据链表是否为空更新头部。

### 3. **理解 `LinkedList` 的性能**

#### 3.1 时间复杂度
- **`get(index)`**：O(n)，因为需要从头部或尾部开始遍历节点，直到找到指定的索引。
- **`add(E e)`**：O(1)，在尾部插入元素时是 O(1) 的操作。
- **`remove(Object o)`**：O(n)，需要遍历链表找到指定元素。
- **插入与删除**：O(1) 在链表头部或尾部插入和删除操作。

#### 3.2 与 `ArrayList` 的比较
- **查询效率**：`LinkedList` 的查询效率较低，因为需要遍历链表，而 `ArrayList` 可以通过索引直接访问元素（O(1)）。
- **插入与删除**：`LinkedList` 更适合频繁插入和删除操作，尤其是头部和尾部，而 `ArrayList` 在中间插入和删除时需要移动大量元素。

### 4. **面试中的应用与常见问题**

在面试中，可能会被问到关于 **`LinkedList`** 和 **`ArrayList`** 的性能对比、使用场景等问题。以下是一些常见的面试问题和回答：

#### 4.1 `LinkedList` 和 `ArrayList` 的区别
- **内存布局**：`ArrayList` 使用动态数组存储元素，而 `LinkedList` 使用链表节点存储元素。
- **访问速度**：`ArrayList` 支持 O(1) 时间复杂度的随机访问，而 `LinkedList` 的访问是 O(n)。
- **插入和删除操作**：在链表的头部和尾部，`LinkedList` 插入和删除的时间复杂度是 O(1)，而 `ArrayList` 需要移动元素，通常是 O(n)。

#### 4.2 `LinkedList` 的使用场景
- **频繁的插入和删除操作**：例如处理队列、栈的实现（`LinkedList` 实现了 `Deque` 接口）。
- **数据量不大且访问顺序性较弱的场景**：适用于需要频繁操作首尾元素的场景。

#### 4.3 `LinkedList` 性能的瓶颈
- **查询性能差**：由于无法直接索引元素，`LinkedList` 在查询时需要遍历，因此查询性能相对较差。
- **额外的内存开销**：每个节点除了存储数据外，还要存储前后节点的引用，因此比 **`ArrayList`** 占用更多的内存。

### 5. **如何深化学习**

- **源码深入分析**：通过查看 `LinkedList` 类的完整源码，学习其实现细节，了解不同操作背后的设计思想。
- **实际场景应用**：在实际项目中，使用 **`LinkedList`** 实现一些功能，体会它在不同场景下的表现。例如，可以使用 **`LinkedList`** 来实现一个任务调度队列或者双端队列。
- **性能分析与调优**：使用 JMH 工具进行性能对比，了解 **`ArrayList`** 和 **`LinkedList`** 在不同场景下的性能差异，并结合实际需求进行选择。

### 6. **总结**

- **学习目标**：理解 **`LinkedList`** 的内部结构，掌握常见操作的实现原理，并能够在面试和实际开发中进行正确的选择。
- **面试准备**：理解 **`LinkedList`** 的基本特性，常见面试题，以及它与 **`ArrayList`** 的对比，能够在不同场景下选择合适的集合类。
- **深入思考**：通过源码分析和实际编码实践，深入理解 **`LinkedList`** 的工作原理，并在性能优化和使用场景上做出合理选择。

根据以上步骤，你可以有针对性地进行学习和实践，理解 **`LinkedList`** 在 Java 中的应用，提升自己的知识深度和实际技能。如果有任何问题或不明白的地方，随时可以提问。



# 问题

## 在尾部插入元素时是 O(1) 的操作。

在 **`LinkedList`** 中，尾部插入元素的操作是 **O(1)** 的，主要是因为其内部结构的特点：**双向链表**。我们可以从以下几个方面来理解这个原理。

### 1. **双向链表的结构**

`LinkedList` 内部是由节点（Node）组成的双向链表。每个节点包含三个部分：
- **数据**（存储具体元素）
- **指向前一个节点的引用（`prev`）**
- **指向下一个节点的引用（`next`）**

对于链表的 **头节点（Head Node）** 和 **尾节点（Tail Node）**，它们分别有对应的指针，指向链表的第一个节点和最后一个节点。

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

- **`prev`**：指向前一个节点。
- **`next`**：指向下一个节点。

### 2. **尾部插入的原理**

在尾部插入元素时，`LinkedList` 只需要做以下几步操作：

- **获取尾节点（last）**：直接获取链表的尾节点。尾节点是 **`LinkedList`** 类的一个成员变量，直接存储了指向链表尾部元素的引用。
- **创建新节点**：创建一个新节点，并将新节点的 `prev` 指向当前尾节点，将 `next` 指向 `null`（表示新的尾部节点没有后续节点）。
- **更新尾部节点**：将尾节点的 `next` 指向新节点，并将 **`LinkedList`** 的尾节点更新为新节点。

### 3. **为什么是 O(1) 操作**

- 在 **`LinkedList`** 中，尾部节点是通过一个成员变量 `last` 直接指向的。插入元素时，**不需要遍历整个链表**，只需要操作尾部节点和新的节点之间的连接关系。
- 插入新元素的过程仅涉及到以下几个步骤：
  1. 创建新节点并设置 `prev` 和 `next` 引用。
  2. 将当前尾节点的 `next` 指向新节点。
  3. 更新尾节点为新节点。

这三个操作不涉及遍历，因此 **时间复杂度为 O(1)**，是常数时间操作。

### 4. **对比 `ArrayList`**

`ArrayList` 在尾部插入时虽然也是 **O(1)**，但是它的实现方式不同。`ArrayList` 是基于数组实现的，当数组满了时，会进行 **扩容** 操作，将现有数据复制到新的更大的数组中，这个过程的时间复杂度是 **O(n)**，因此，频繁的尾部插入会导致性能下降。而 `LinkedList` 的尾部插入只涉及节点的引用更新，所以没有这种扩容问题。

### 5. **代码示例**

下面是 **`LinkedList`** 中 `add` 方法的简单实现：

```java
public void add(E e) {
    linkLast(e);  // 将元素添加到尾部
}

private void linkLast(E e) {
    final Node<E> l = last;  // 获取当前尾部节点
    final Node<E> newNode = new Node<>(l, e, null);  // 创建新节点
    last = newNode;  // 更新尾节点
    if (l == null) {
        first = newNode;  // 如果链表为空，新节点是头部
    } else {
        l.next = newNode;  // 将原尾部节点的 next 指向新节点
    }
    size++;  // 增加链表大小
}
```

### 6. **总结**

- **O(1)** 时间复杂度的尾部插入是因为 `LinkedList` 保持了对尾节点的引用，插入新节点时不需要遍历链表。
- 插入时的操作是局部的，仅涉及尾节点和新节点之间的连接，不需要移动其他元素或扩容。

## 如果插入到倒数第二个呢

如果要在 **倒数第二个位置** 插入元素，`LinkedList` 的操作不再是 O(1)，因为你需要找到倒数第二个元素的位置。尽管 `LinkedList` 提供了快速的尾部插入（O(1)），但在其他位置的插入或删除操作，特别是像倒数第二个位置这样的操作，通常是 **O(n)**。

下面详细解释插入到倒数第二个位置的步骤以及原因：

### 1. **操作过程**

在插入到倒数第二个元素时，我们需要进行以下几个步骤：

#### 1.1. **获取倒数第二个节点的位置**

- 如果你要插入的位置是倒数第二个节点，你首先需要遍历到倒数第二个节点。可以从尾节点开始，沿着链表向前移动一步，直到到达倒数第二个节点。**这需要遍历链表，因此时间复杂度是 O(n)**，其中 n 是链表的长度。
  
#### 1.2. **插入操作**

- 在找到了倒数第二个节点之后，插入新节点的操作与尾部插入类似：将倒数第二个节点的 `next` 指向新节点，并将新节点的 `prev` 指向倒数第二个节点。然后，更新新节点的 `next` 为原来的倒数第一个节点（即倒数第二个节点的 `next`），同时原来倒数第一个节点的 `prev` 指向新节点。

#### 1.3. **更新链表大小**

- 最后，链表的大小增加 1，插入操作完成。

### 2. **时间复杂度分析**

- 由于我们需要从尾节点遍历到倒数第二个节点，因此这个过程需要 **O(n)** 的时间，n 是链表的长度。即使我们只进行一次操作插入，也需要遍历链表的元素来找到插入点。
  
- 因此，在倒数第二个位置插入的时间复杂度是 **O(n)**。

### 3. **代码示例**

假设我们有一个 `LinkedList`，我们要在倒数第二个位置插入元素，代码大致如下：

```java
public void insertBeforeLast(E e) {
    if (size < 2) {
        throw new IllegalArgumentException("List must have at least two elements.");
    }

    Node<E> lastNode = last;  // 获取尾节点
    Node<E> secondLastNode = lastNode.prev;  // 获取倒数第二个节点

    Node<E> newNode = new Node<>(secondLastNode, e, lastNode);  // 创建新节点
    secondLastNode.next = newNode;  // 将倒数第二个节点的 next 指向新节点
    lastNode.prev = newNode;  // 将尾节点的 prev 指向新节点

    size++;  // 增加链表大小
}
```

### 4. **对比尾部插入**

- **尾部插入**：只需要 O(1) 时间，因为我们可以直接访问尾节点，而不需要遍历链表。
- **倒数第二个位置插入**：需要 O(n) 时间，因为我们必须找到倒数第二个节点并进行插入操作。

### 5. **为什么是 O(n)**

- `LinkedList` 是一个线性结构，插入或删除操作通常需要找到正确的位置。尽管我们可以通过 `prev` 和 `next` 快速遍历节点，但链表并不像 **`ArrayList`** 那样能通过索引快速访问，因此需要遍历链表。

### 6. **总结**

- **尾部插入**：由于链表有尾节点的引用，可以直接插入元素，时间复杂度是 O(1)。
- **倒数第二个位置插入**：由于需要从尾部往前遍历找到倒数第二个节点，因此时间复杂度是 **O(n)**。



让我再详细地解释一下为什么在倒数第二个位置插入元素是 O(n) 操作，特别是如何理解链表结构的遍历过程和为什么插入操作涉及到 O(n) 的时间复杂度。

### 1. **链表的基本结构**

`LinkedList` 是由一系列节点（`Node`）组成的，每个节点包含三个部分：

- **数据部分**：存储节点的数据。
- **前向指针（`prev`）**：指向链表中前一个节点。
- **后向指针（`next`）**：指向链表中下一个节点。

这使得 `LinkedList` 支持双向遍历：可以通过 `next` 指针向前遍历，也可以通过 `prev` 指针向后遍历。

### 2. **尾部插入为什么是 O(1)**

在 `LinkedList` 中，尾部插入是 O(1) 的操作，因为：

- `LinkedList` 中通常会有一个指向 **尾节点** (`last`) 的引用。尾节点的 `prev` 指针指向倒数第二个节点，而 `next` 指针为 `null`。
- 如果我们直接在尾部插入，只需要将新的节点插入到当前尾节点之前，并更新尾节点的 `next` 指针指向新的节点，再更新新节点的 `prev` 指针指向原尾节点，然后更新尾节点为新的节点。所有这些操作都是常数时间 O(1)。
  
### 3. **插入到倒数第二个位置为什么是 O(n)**

当我们要在倒数第二个位置插入元素时，我们并不能直接像尾部插入那样快速操作。具体原因是我们需要 **找到倒数第二个节点**。但是，在 `LinkedList` 中，并没有直接指向倒数第二个节点的引用。

因此，步骤如下：

#### 3.1. **获取倒数第二个节点的位置**

- 要找到倒数第二个节点，我们通常需要从 **尾节点** 开始遍历。这是因为链表并不像数组那样支持随机访问。我们从尾节点的 `prev` 开始，步步往前查找，直到找到倒数第二个节点。
  
  - 比如，如果链表的元素个数为 10，我们需要从尾节点（第 10 个元素）开始，向前访问 1 次，才能到达倒数第二个元素（第 9 个元素）。

- **这个过程是线性的**，因此需要 O(n) 的时间，其中 n 是链表的长度。因为我们需要遍历链表的元素来找到插入点，所以这个操作是 O(n) 的。

#### 3.2. **插入操作**

- 一旦找到了倒数第二个节点，插入操作就和普通的链表插入类似：修改相邻节点的 `next` 和 `prev` 指针，将新节点插入到倒数第二个节点之后。

#### 3.3. **时间复杂度分析**

- 查找倒数第二个节点的过程需要 O(n) 的时间，因为我们需要从尾节点开始遍历，逐个访问节点。
- 插入操作本身，即更新相邻节点的指针，是 O(1) 的操作，因为一旦找到插入位置，操作非常简单。

因此，总体来说，查找位置的时间复杂度是 O(n)，插入操作是 O(1)，所以插入到倒数第二个位置的总时间复杂度是 O(n)。

### 4. **为什么遍历需要 O(n) 时间**

- **链表的结构**：链表没有随机访问功能。每个节点只能通过 `prev` 和 `next` 指针连接起来。尽管我们知道尾节点的位置，但倒数第二个节点并不直接可达，需要从尾节点开始逐步向前查找。这种查找是逐个节点的过程，因此是 O(n) 时间。
  
- **没有索引**：不像数组（`ArrayList`）可以通过索引直接访问元素，`LinkedList` 必须通过指针遍历每个元素，直到找到目标位置。这样，查找某个特定位置的元素就成为了一个线性操作。

### 5. **代码示例**

假设我们有一个链表，下面是一个在倒数第二个位置插入元素的代码示例：

```java
public void insertBeforeLast(E e) {
    if (size < 2) {
        throw new IllegalArgumentException("List must have at least two elements.");
    }

    Node<E> lastNode = last;  // 获取尾节点
    Node<E> secondLastNode = lastNode.prev;  // 获取倒数第二个节点

    Node<E> newNode = new Node<>(secondLastNode, e, lastNode);  // 创建新节点
    secondLastNode.next = newNode;  // 将倒数第二个节点的 next 指向新节点
    lastNode.prev = newNode;  // 将尾节点的 prev 指向新节点

    size++;  // 增加链表大小
}
```

在这段代码中，我们首先需要找到倒数第二个节点 `secondLastNode`，然后在该节点后插入新节点。这个过程包含了对链表的遍历操作，导致时间复杂度是 O(n)。

### 6. **总结**

- **尾部插入 O(1)**：因为有尾节点的引用，直接操作。
- **倒数第二个位置插入 O(n)**：因为必须从尾节点开始遍历，逐个访问节点，找到倒数第二个节点后才能插入。

在链表中，插入和删除操作的时间复杂度通常取决于查找插入或删除位置的复杂度。如果插入点靠近链表的尾部或头部，查找操作更快（O(1)），但如果插入点较为靠近链表的中间，就会变成 O(n)。



## 插入速度对比

这个需要根据插入的位置来比较

如果Array插入的是尾部，同时不需要扩容，则速度也挺快。

如果Linked插入的不是尾部，则需要遍历，速度不会很快。

要比较 `ArrayList` 和 `LinkedList` 在插入操作上的速度，我们需要从两个方面来考虑：**查找插入位置的时间**和**插入操作本身的时间**。

### 1. **查找插入位置**
- **`ArrayList`**：由于 `ArrayList` 内部是一个基于数组的实现，它可以通过索引直接访问到任何位置。因此，**查找插入位置的时间是 O(1)**，只需要计算插入位置的索引就可以直接找到。

- **`LinkedList`**：由于 `LinkedList` 是基于节点（每个节点包含前驱和后继节点）实现的，它不能通过索引直接访问任何位置。要找到插入位置，必须从头节点或者尾节点开始，遍历链表，直到找到目标位置。因此，**查找插入位置的时间是 O(n)**，最坏情况下需要遍历整个链表。

### 2. **插入操作**
- **`ArrayList`**：在插入操作时，如果要插入的位置不是数组的末尾，那么它需要 **移动元素** 来腾出空间。比如，插入一个元素时，所有后续元素（从插入位置到数组末尾的元素）都需要向后移动一个位置。这是一个**O(n)** 的操作。

  - **尾部插入**：如果是插入到 `ArrayList` 的尾部，并且数组有足够的空间，则是 O(1) 的操作。如果没有足够的空间，它会触发扩容，扩容的时间复杂度是 O(n)，因为需要将旧数据复制到新的数组中。
  
- **`LinkedList`**：在插入操作时，不需要移动其他节点。只需要修改相邻节点的 `next` 和 `prev` 指针即可，这个操作是 O(1) 的，**前提是你已经找到了插入位置**。

### 3. **综合对比**

- **`ArrayList`** 插入操作的性能受限于插入位置。如果你要在中间位置插入元素，由于需要移动大量元素，所以插入操作的时间复杂度是 **O(n)**，而查找插入位置的时间是 O(1)。
  
- **`LinkedList`** 插入操作的性能主要受限于查找插入位置的时间。查找插入位置的时间复杂度是 O(n)，而插入操作本身是 O(1) 的。

因此，**如果插入位置不在尾部**，`LinkedList` 在 **查找插入位置** 时的时间复杂度是 O(n)，而 `ArrayList` 在 **移动元素** 时的时间复杂度也是 O(n)，所以从时间复杂度的角度来看，两者的表现差不多。

### 4. **实际场景的区别**

- **`ArrayList`**：适合频繁进行 **随机访问** 和 **尾部插入** 的场景。因为它允许通过索引直接访问元素，查找插入位置的速度更快。如果你经常需要在中间插入或者删除元素，`ArrayList` 的性能可能会变得较差。

- **`LinkedList`**：适合频繁进行 **插入** 和 **删除** 的场景，尤其是操作链表头尾时。如果你需要经常在链表的中间进行插入和删除操作，`LinkedList` 的性能会更好，因为它不需要移动大量元素，而是通过修改指针来完成操作。

### 5. **总结**
- 如果插入位置接近 **头部或中间**，`LinkedList` 在 **查找插入位置** 时可能更慢，但它的 **插入操作** 是 O(1)，不会像 `ArrayList` 那样需要移动大量元素。因此，对于频繁的插入操作，`LinkedList` 可能会有优势，尤其是当插入点接近链表头部时。
- 如果插入位置接近 **尾部**，`ArrayList` 的性能通常更好，因为它在尾部插入时是 O(1) 的，并且没有移动其他元素的开销。