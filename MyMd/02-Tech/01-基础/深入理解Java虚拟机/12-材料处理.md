并发处理的广泛应用

Amdahl定律

计算机性能发展源动力



## 12.1 概述

```
计算机同时做几件事情

运算能力强大

xxx运算速度与xxx的速度差距大

时间花在xxx上
```

```
服务端
客户端
服务
并发应用场景

服务性能
每秒事务处理数
响应的请求总数
TPS 并发能力
阻塞 死锁
有条不紊
```

```
写好并发应用  开发的难点
工具  并发编程门槛
中间件服务器，框架  并发细节  业务逻辑
所有的并发处理的事情  并发的内幕
```

```
实现多线程
共享  竞争  问题  方案
```

## 12.2 硬件的效率与一致性

```
物理计算机中的并发问题
相似  处理方案  参考
```

```
并发执行  处理器的效能
复杂性的来源  处理器的计算  内存交互
读写速度差距  多层高速缓存  缓冲  等待
```

```
高速缓存的存储交互  处理器与内存速度的矛盾  复杂度
缓存一致性
多路处理器  共享统一主内存   缓存数据不一致
访问缓存  协议  
内存模型  读写访问的过程抽象
```

```
运算单元充分利用  乱序执行优化  重组
```

## 12.3 Java内存模型

```
Java内存模型  内存访问差异  一致的内存访问效果
不同平台内存模型差异  代码不能正常运行
```

```
宽松  硬件的特性
严谨  访问操作没有歧义

```

### 12.3.1 主内存与工作内存

```
Java内存模型  变量的访问规则
存储  提取  变量值  内存 
变量：实例字段，静态字段，构成数组对象的元素
不包括：局部变量与方法参数  线程私有的

不限制使用  
特定的寄存器-缓存  主内存
即时编译器  调整代码顺序
```

`````
主内存 ： 所有变量
线程： 自己的工作内存 ： 变量（主内存副本）
对变量的操作  工作内存中

不同线程  对方工作内存的变量  值传递  主内存
`````

```
这里的主内存 工作内存  
第二章：Java堆，栈，方法区
不是同一个层地的内存划分 没有关系

主内存 ： Java堆（对象的实例数据）
工作内存 ： 虚拟机栈的部分区域

更基础：
主内存：物理的内存
工作内存：寄存器 高速缓存 程序优先访问的区域
```

### 12.3.2 内存间交互操作

```
主内存-工作内存  交互协议
8种操作  原子  不可再分
```

```
主内存
lock : 
变量  一条线程独占的状态
unlock : 
变量  锁定状态 》 未锁定状态
read : 
变量的值  主内存 传输 线程的工作内存  》 load
```

```
工作内存
load : 
主内存过来的变量 工作内存的变量副本中
use : 
工作内存中一个变量的值  执行引擎
虚拟机  需要使用变量的值的字节码指令
assign : 
执行引擎接收到的值  工作内存的变量
虚拟机  给变量赋值的字节码指令
store : 
工作内存变量的值  主内存  》 write
```

```
主内存
write :
变量的值  主内存的变量中
```



```
read  load  
store write
不可分割  顺序执行
先load  store
才能 use  write
```

```
工作内存
变量改变  assign
同步回主内存
```

```
没有assign的变量
不能同步回主内存
```

```
新的变量  主内存  诞生
未被初始化的变量（assign load）

先assign  再use
先load  再store
```

```
lock n次  unlock n次
```

```
lock 变量  工作内存 清空变量的值
```

```
未lock  不能unlock
```

```
unlock前  变量 同步回主内存
意思：在主内存中Unlock，那lock也是吧
```



### 12.3.3 对于volatile型变量的特殊规则

```
volatile 最轻量级的同步机制 
理解volatile变量的语义  理解多线程操作的其他特性
```

```
变量被定义成volatile  2个特性
可见性  其他所有线程
修改后  其他线程立即得知

对比：普通变量
需要回写到主内存，其他线程才能访问
```

```
可见性  线程安全  

操作的非原子性  volatile变量的不一致
方案：
加锁 synchronized java.util.concurrent
```



```
内存屏障  控制内存操作的顺序
```

